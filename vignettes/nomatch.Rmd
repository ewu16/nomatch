---
title: "nomatch"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{nomatch}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 6,
  fig.height = 3
)
```


```{r core_pkgs, echo=FALSE, warning = FALSE, message = FALSE}
library(tibble)
library(ggplot2)
library(dplyr)
```

## Introduction

The `nomatch` package is designed to use a G-computation style estimator to compute
estimates of marginal cumulative incidence in observational cohort studies with a binary exposure and time-to-event outcome. 
The estimator aligns with the target trial emulation framework (Hernan 2016) and provides
an alternative to matching methods, which can suffer from substantial efficiency loss.
The estimator adjusts for baseline confounders and time to exposure, which may be measured on 
calendar time scale, age, or other time scale, by fitting
two conditional Cox models. These models are used to compute marginal 
cumulative incidence under "interventions" of exposure and no exposure;
derived effect measures such as risk differences, risk ratios, and vaccine effectiveness are also provided. 



## nomatch 

We examine the use of `nomatch` to produce estimates of effectiveness for a
binary exposure (intervention). The package can be loaded as follows: 

```{r setup}
library(nomatch)
```

We will illustrate the use of the package using the simple simulated dataset `simdata` 
included in the package. For exposition, we will pretend this dataset represents data from an 
observational vaccine study. In practice, data from other disease settings can be used as well. 
The first few rows of `simdata` can be viewed as follows:


```{r}
simdata <- as_tibble(simdata) #for prettier printing

#View data
head(simdata)
```


The data contains one row per individual (`ID`) and a set of baseline covariates (`x1`, `x2`). 
There are two variables related to an individual's exposure which are 1) their vaccination status (`V`), a binary indicator with values `1 = vaccinated, 0 = unvaccinated` 
and 2) their time to receiving vaccination (`D_obs`), a numeric value or 
`NA` for unvaccinated individuals.
The data also includes right-censored survival outcomes`(Y, event)` where `Y` represents follow-up time for an outcome (e.g. infection or death), and `event` indicates whether the individual experienced the event with values `1 = event, 0 = censored`. 

We will assume that time to vaccination `D_obs` and time to outcome `Y` are measured relative
to a calendar date of study start; this is motivated by the fact that calendar time is
often an important time scale in vaccine studies due to changing infection dynamics. In other settings, relevant time scales may include
time since enrollment or other meaningful event, or age. Regardless of the choice of time scale, 
the same time origin should be used to define the time to exposure and time to outcome variables, 
as well as the baseline covariates. 


### Estimating cumulative incidence

To learn about the real-world effectiveness of an intervention, we can try to
compare the incidence of failure at a fixed time under the active and control exposure. 
We assume that the exposed group consists of initiators (.e.g vaccinated individuals) 
and that the non-exposed group consists of non-initiators (e.g. unvaccinated individuals).
A challenge in analyzing such data is that the start of follow-up is not well-defined for the
unexposed group. One way to circumvent this issue is to imagine that we can assign individuals in a certain covariate group to receive an exposure (or no exposure) on a certain day. In this case, the natural start of follow-up 
is the assigned day for receiving the exposure, just as start of follow-up in a randomized trial coincides with the day of randomization. 
This allows us to define cumulative incidences of the outcome for each intervention-day and for each covariate group. 
These day- and covariate-specific cumulative incidences can then be marginalized (e.g. over the distribution of
exposure days and covariates among those observed to be exposed) to obtain
overall cumulative incidence estimates. 

We can invoke the `nomatch` function to compute these marginal cumulative incidences. 
Here, we need to provide several types of arguments: 

- `data, outcome_time, outcome_status, exposure, exposure_time, covariates`: First, we need to provide  our dataset and the names of the variables in the dataset that describe the outcome, exposure, and covariates to adjust for. 

- `immune_lag, eval_times`: Then we specify what cumulative incidences to compute. The first argument, `immune_lag`,
is used to compute cumulative incidences that ignore events that occur within `immune_lag` days; the population of interest is 
defined to be the subset of individuals who would remain endpoint-free `immune_lag` days after exposure. This is often used in vaccine studies because the vaccine takes time to induce an immune response and become effective. We will set `immune_lag = 14` (2 weeks) for our pretend vaccine study, but this can also be set to `0` when not relevant
to the setting of interest. The second argument, `eval_times`, specifies the timepoints of interest
for evaluating cumulative incidence. Here we've specified to compute
the cumulative incidence of infection/severity outcomes occurring within `30, 60, 90, ..180`
days after vaccination. 

- `boot_reps`: Since confidence intervals for the estimated cumulative incidences and effect measures are based on bootstrapping procedures, we need to provide the number of bootstrap replications. Note that we use a small number here so the example runs quicly,
but `boot_reps = 1000` is recommended to construct reliable confidence intervals for interpretation. By default, Wald-style bootstrap confidence intervals and p-values are returned. 



```{r}

# Compute cumulative incidence 
fit <- nomatch(data = simdata,
                  outcome_time = "Y",
                  outcome_status = "event",
                  exposure = "V",
                  exposure_time = "D_obs", 
                  covariates = c("x1", "x2"),
                  immune_lag = 14,
                  eval_times = seq(30, 180, by = 30),
                  boot_reps = 10)


```

Here we see the vaccine effectiveness estimates for our simulated dataset. 

```{r}
fit
```

The cumulative incidence estimates (`cuminc_0` for unexposed and  `cuminc_1` for exposed) ) and other effects (`risk_difference`, `risk_ratio`, and `vaccine_effectiveness`) are also stored within the 
fitted object. These can be examined via `fit$estimates`. 

If all confounders are adjusted for, the resulting cumulative incidence/effect estimates can be interpreted as the cumulative incidences/effect that would be observed in a clinical trial in which participants 1) are similar to those observed to be exposed and 2) who enroll into the study such that the distribution of enrollments times matches the distribution of observed exposure times. 

### Additional details about estimation approach 

Internally, the cumulative incidence estimates are computed by fitting two 
Cox models- one model for the unexposed and one model for the exposed. In the model for the unexposed, time to the endpoint of interest is measured relative to the study start (or chosen time origin). The unexposed model includes all individuals, where 
exposed individuals are censored at the time of exposure, and adjusts for covariates.
In the model for the exposed, the time to endpoint of interest is measured relative to the time of
exposure. The model includes all exposed individuals at risk `immune_lag` days after exposure,
flexibly adjusting for the time of exposure (by default, using natural cubic splines with four degrees of freedom), as well baseline covariates. A summary of the estimation approach and fitted models can be obtained by 
```{r}
summary(fit)
```


These Cox models are used to predict  day and covariate specific cumulative incidences which are then, by default,  marginalized over the observed
distribution of exposure times and covariates in the exposed. The weights used 
for marginalization are returned in the `$weights` component of the fitted object. 

### Plotting cumulative incidence curves


We can make a quick panel plot of the cumulative incidence and vaccine effectiveness estimates
over time using `plot()`. Note that if cumulative incidence curves are of interest, it is recommended
to provide a fine grid of `eval_times` to produce smooth curves. 
Our example plot will be somewhat crude due to the small number of timepoints used in the function call. 

```{r}
plot(fit)
```

#### Plotting simultaneous confidence intervals 

Note that in the plot above, we have plotted the pointwise confidence intervals, which
are just the usual 95% confidence intervals plotted at each timepoint. If instead of
inference on each timepoint, we would like to make inference 
on the entire curve, we need to construct simultaneous confidence intervals. 
We can do this using the `add_simulatenous_ci()` function which computes simultaneous confidence intervals given an existing fitted object, provided that the bootstrap samples were saved in the object (i.e. `keep_boot_samples = TRUE`, the default). This function returns the original fitted object updated with simultaneous confidence intervals
which we now save in a new object. 

```{r}
#Compute simultaneous CI
fit_with_simul <- add_simultaneous_ci(fit, seed = 1234)
```

The simultaneous confidence interals are now printed with the object.  
```{r}
fit_with_simul
```

We can also plot the cumulative incidence curves with simultaneous confidence intervals
by providing the `ci_type` argument. Note that the simultaneous confidence intervals must be
computed before plotting; otherwise, the call will error. 

```{r}
#Plot simultaneous confidence bands 
plot(fit_with_simul , ci_type = "simul") 
```

The simultaneous confidence intervals indicate that if we were to repeatedly construct
simultaneous confidence intervals on new samples of data, then 95% of the constructed
simultaneous confidence bands would contain the true cumulative inicdence/effectiveness curve. 

### Creating custom plots

Often, users may wish to create their own custom plots. This can be done by
extracting the estimates from the fitted object and creating a long tidy-style data frame. 
The utility function `estimates_to_df()` takes the `estimates` component
of the fitted object and reformats it as a long dataset that can be used for plotting. 

```{r}
plot_data <- estimates_to_df(fit)

head(as_tibble(plot_data))
```

For example, we can create a plot that overlays the cumulative incidence estimates
for the two exposure types as follows:

```{r}
plot_data |> 
  filter(term %in% c("cuminc_0", "cuminc_1")) |> 
  ggplot(aes(x = t0, y = estimate, color = term, fill = term)) + 
  geom_line() + 
  geom_ribbon(aes(ymin = wald_lower, ymax = wald_upper), alpha = 0.2, linewidth = 0) + 
  theme_bw() +
  scale_color_discrete(breaks = c("cuminc_0", "cuminc_1"), labels = c("Unvaccinated", "Vaccinated"))+
  scale_fill_discrete(breaks = c("cuminc_0", "cuminc_1"), labels = c("Unvaccinated", "Vaccinated"))+ 
  labs(x = "Time since vaccination",
       y = "Estimate",
       title = "Cumulative Incidence Curves", 
       color = "Exposure Group",
       fill = "Exposure Group")
  
```



### Comparison with matching 

The G-computation estimation approach is generally expected to produce
similar point estimates as a simple analysis using rolling-cohort matching in which exposed individuals are 
matched to an eligible unexposed individual at their time of exposure on 
key covariates. An advantage of the G-computation estimation approach is that it offers greater precision, which may be pecially valuable when the data involves smaller samples sizes or rare endpoints. To aid comparison of the two approaches, we provide a simple implementation of a matching approach
that uses a rolling cohort design with 1:1 exact matching and Kaplan Meier estimation for
computing marginal cumulative incidences. Note that the functions for implementing matching
may take a while to run on large datasets. They are also intentionally limited in 
scope, serving only to provide a simple matching comparison. 

```{r}
# ------------------------------------------------------------------------------
# 3. Compare results with matching estimator

matched_cohort <- match_rolling_cohort(data = simdata,
                                       outcome_time = "Y",
                                       exposure = "V",
                                       exposure_time = "D_obs", 
                                       matching_vars = c("x1", "x2"),
                                       id_name = "ID",
                                       seed = 5678)

matched_data <- matched_cohort[[1]]


fit_matching <-matching(matched_data = matched_data,
                           outcome_time = "Y",
                           outcome_status = "event",
                           exposure = "V",
                           exposure_time = "D_obs", 
                           immune_lag = 14,
                           eval_times = seq(30, 180, by = 30),
                           boot_reps = 10) 

fit_matching

# Plot matching vs proposed estimator - nomatch tends to have similar point estimates but narrower
# confidence intervals
compare_ve_fits(fit_matching, fit, labels = c("Matching", "nomatch (G-computation)"))
```





## Session Information

```{r seesionInfo, echo = FALSE}
sessionInfo()
```




